---
to: "<%= generate.drizzleSchema ? outputPaths.drizzleSchema : '' %>"
force: true
---
/**
 * <%= className %> Drizzle Schema
 * Generated by entity codegen - do not edit directly
 */

<% if (hasRelationships) { -%>
import { relations } from 'drizzle-orm';
<% } -%>
<%
// Database dialect-specific imports
const isPostgres = databaseDialect === 'postgres';
const isSqlite = databaseDialect === 'sqlite';
const dbCore = isPostgres ? 'drizzle-orm/pg-core' : 'drizzle-orm/sqlite-core';

// Map Postgres imports to SQLite equivalents
const sqliteImportMap = {
  'pgTable': 'sqliteTable',
  'pgEnum': 'text', // SQLite doesn't have native enums
  'uuid': 'text',
  'varchar': 'text',
  'doublePrecision': 'real',
  'timestamp': 'integer', // Use Unix timestamps for SQLite
  'date': 'text', // ISO 8601 date strings
  'jsonb': 'text', // JSON as text in SQLite
  'boolean': 'integer', // 0/1 in SQLite
  'integer': 'integer',
  'text': 'text',
};

// Get imports based on dialect
const dialectImports = isSqlite
  ? [...new Set(drizzleImports.map(imp => sqliteImportMap[imp] || imp))]
  : drizzleImports;

// Determine if we need index import
const needsIndex = hasEntityRefFields || belongsToRelations.length > 0 || fields.some(f => f.index);
-%>
import {
<% dialectImports.forEach((imp) => { -%>
	<%= imp %>,
<% }) -%>
<% if (needsIndex) { -%>
	index,
<% } -%>
} from '<%= dbCore %>';
<%
// Collect unique non-self-referential schema imports
const importedSchemas = new Set();
[...belongsToRelations, ...hasManyRelations, ...hasOneRelations].forEach((rel) => {
  if (rel.targetPlural !== plural) {
    importedSchemas.add(rel.targetPlural);
  }
});
-%>
<% importedSchemas.forEach((targetPlural) => { -%>
import { <%= targetPlural %> } from './<%= targetPlural %>.schema';
<% }) -%>
<% if (hasEntityRefFields) { -%>
import { entityTypeEnum } from './entity-types.schema';
<% } -%>
<% if (enumFields.length > 0 && isPostgres) { -%>

// Enum definitions (Postgres only)
<% enumFields.forEach((field) => { -%>
export const <%= field.enumName %> = pgEnum('<%= field.name %>', [<%- field.choices.map(c => `'${c}'`).join(', ') %>]);
<% }) -%>
<% } -%>
<%
// Table function name based on dialect
const tableFunc = isPostgres ? 'pgTable' : 'sqliteTable';
-%>

export const <%= plural %> = <%= tableFunc %>('<%= table %>', {
<% if (isPostgres) { -%>
	id: uuid('id').defaultRandom().primaryKey(),
<% } else { -%>
	id: text('id').primaryKey().$defaultFn(() => crypto.randomUUID()),
<% } -%>
<% fields.forEach((field) => { -%>
<% const colName = field.name.replace(/([A-Z])/g, '_$1').toLowerCase(); -%>
<% // Check if this field is a FK for a belongs_to relationship -%>
<% const belongsToRel = belongsToRelations.find(r => r.foreignKeyCamel === field.camelName); -%>
<% if (field.drizzleType === 'entity_type_enum') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: entityTypeEnum('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: text('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } -%>
<% } else if (field.drizzleType === 'text_array') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: text('<%= colName %>').array()<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: text('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>, // JSON array in SQLite
<% } -%>
<% } else if (field.drizzleType === 'enum') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: <%= field.enumName %>('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: text('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>, // Enum as text in SQLite
<% } -%>
<% } else if (field.drizzleType === 'varchar') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: varchar('<%= colName %>'<%= field.maxLength ? `, { length: ${field.maxLength} }` : '' %>)<%= field.required && !field.nullable ? '.notNull()' : '' %><%= field.unique ? '.unique()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: text('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %><%= field.unique ? '.unique()' : '' %>,
<% } -%>
<% } else if (field.drizzleType === 'uuid') { -%>
<% if (belongsToRel) { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: uuid('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>.references(() => <%= belongsToRel.targetPlural %>.id),
<% } else { -%>
	<%= field.camelName %>: text('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>.references(() => <%= belongsToRel.targetPlural %>.id),
<% } -%>
<% } else { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: uuid('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %><%= field.unique ? '.unique()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: text('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %><%= field.unique ? '.unique()' : '' %>,
<% } -%>
<% } -%>
<% } else if (field.drizzleType === 'integer') { -%>
	<%= field.camelName %>: integer('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } else if (field.drizzleType === 'decimal') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: doublePrecision('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: real('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } -%>
<% } else if (field.drizzleType === 'boolean') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: boolean('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %><%= field.default !== undefined ? `.default(${field.default})` : '' %>,
<% } else { -%>
	<%= field.camelName %>: integer('<%= colName %>', { mode: 'boolean' })<%= field.required && !field.nullable ? '.notNull()' : '' %><%= field.default !== undefined ? `.default(${field.default ? 1 : 0})` : '' %>,
<% } -%>
<% } else if (field.drizzleType === 'date') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: date('<%= colName %>', { mode: 'date' })<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: text('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>, // ISO 8601 date string
<% } -%>
<% } else if (field.drizzleType === 'timestamp') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: timestamp('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: integer('<%= colName %>', { mode: 'timestamp' })<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } -%>
<% } else if (field.drizzleType === 'jsonb') { -%>
<% if (isPostgres) { -%>
	<%= field.camelName %>: jsonb('<%= colName %>')<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } else { -%>
	<%= field.camelName %>: text('<%= colName %>', { mode: 'json' })<%= field.required && !field.nullable ? '.notNull()' : '' %>,
<% } -%>
<% } -%>
<% }) -%>
<% /* ================================================================== */ -%>
<% /* Behavior fields - generated based on behaviors array               */ -%>
<% /* ================================================================== */ -%>
<% if (hasTimestamps) { -%>
	// timestamps behavior
<% if (isPostgres) { -%>
	createdAt: timestamp('created_at').defaultNow().notNull(),
	updatedAt: timestamp('updated_at').defaultNow().notNull(),
<% } else { -%>
	createdAt: integer('created_at', { mode: 'timestamp' }).$defaultFn(() => new Date()).notNull(),
	updatedAt: integer('updated_at', { mode: 'timestamp' }).$defaultFn(() => new Date()).notNull(),
<% } -%>
<% } -%>
<% if (hasSoftDelete) { -%>
	// soft_delete behavior
<% if (isPostgres) { -%>
	deletedAt: timestamp('deleted_at'),
<% } else { -%>
	deletedAt: integer('deleted_at', { mode: 'timestamp' }),
<% } -%>
<% } -%>
<% if (hasUserTracking) { -%>
	// user_tracking behavior
<% if (isPostgres) { -%>
	createdBy: uuid('created_by'),
	updatedBy: uuid('updated_by'),
<% } else { -%>
	createdBy: text('created_by'),
	updatedBy: text('updated_by'),
<% } -%>
<% } -%>
<% if (hasTemporalValidity) { -%>
	// temporal_validity behavior
<% if (isPostgres) { -%>
	validFrom: timestamp('valid_from'),
	validTo: timestamp('valid_to'),
	isActive: boolean('is_active').default(true).notNull(),
<% } else { -%>
	validFrom: integer('valid_from', { mode: 'timestamp' }),
	validTo: integer('valid_to', { mode: 'timestamp' }),
	isActive: integer('is_active', { mode: 'boolean' }).default(1).notNull(),
<% } -%>
<% } -%>
}<%
// Determine if we need a table config function for indexes
const fkIndexes = belongsToRelations.map(rel => ({
  name: rel.foreignKeyCamel,
  colName: rel.foreignKey.replace(/([A-Z])/g, '_$1').toLowerCase()
}));
const fieldIndexes = fields.filter(f => f.index).map(f => ({
  name: f.camelName,
  colName: f.name.replace(/([A-Z])/g, '_$1').toLowerCase()
}));
const allIndexes = [...fkIndexes, ...fieldIndexes];
const hasTableConfig = hasEntityRefFields || allIndexes.length > 0;
-%>
<% if (hasTableConfig) { -%>, (table) => ({
<% entityRefFields.forEach((ref) => { -%>
	<%= ref.camelName %>Idx: index('idx_<%= table %>_<%= ref.name %>').on(table.<%= ref.camelName %>EntityType, table.<%= ref.camelName %>EntityId),
<% }) -%>
<% allIndexes.forEach((idx) => { -%>
	<%= idx.name %>Idx: index('idx_<%= table %>_<%= idx.colName %>').on(table.<%= idx.name %>),
<% }) -%>
})<% } -%>);
<% if (hasRelationships) { -%>
<%
const usesOne = belongsToRelations.length > 0 || hasOneRelations.length > 0;
const usesMany = hasManyRelations.length > 0;
const destructured = [usesOne ? 'one' : '', usesMany ? 'many' : ''].filter(Boolean).join(', ');
-%>

export const <%= plural %>Relations = relations(<%= plural %>, ({ <%= destructured %> }) => ({
<% belongsToRelations.forEach((rel) => { -%>
	<%= rel.name %>: one(<%= rel.targetPlural %>, {
		fields: [<%= plural %>.<%= rel.foreignKeyCamel %>],
		references: [<%= rel.targetPlural %>.id],
	}),
<% }) -%>
<% hasManyRelations.forEach((rel) => { -%>
	<%= rel.name %>: many(<%= rel.targetPlural %>),
<% }) -%>
<% hasOneRelations.forEach((rel) => { -%>
	<%= rel.name %>: one(<%= rel.targetPlural %>),
<% }) -%>
}));
<% } -%>

export type <%= className %>Record = typeof <%= plural %>.$inferSelect;
export type New<%= className %>Record = typeof <%= plural %>.$inferInsert;
