---
to: <%= basePaths.backendSrc %>/<%= paths.repositories %>/<%= name %>.repository.ts
force: true
---
/**
 * <%= className %> Repository Implementation
 * Generated by entity codegen - do not edit directly
 */
<% if (behaviorStrategy === 'base_class') { -%>

import { Injectable } from '@nestjs/common';
import { eq<%= hasEntityRefFields ? ', and' : '' %> } from 'drizzle-orm';
import { BaseRepository, type BehaviorConfig } from '../base.repository';
<% if (hasEntityRefFields) { -%>
import type { EntityType } from '<%= locations.dbSchemaServer.import %>';
<% } -%>
import type {
	Create<%= className %>Input,
	I<%= className %>Repository,
	Update<%= className %>Input,
<% if (hasRelationships) { -%>
	<%= className %>With,
<% } -%>
} from '../../../domain';
<%
// Collect unique entity imports - only include relationships with existing target entities
const entityImports = new Set([className]);
if (hasExistingRelationships) {
  [...existingBelongsTo, ...existingHasMany, ...existingHasOne].forEach((rel) => {
    entityImports.add(rel.targetClass);
  });
}
-%>
import { <%- [...entityImports].join(', ') %> } from '../../../domain';
import { <%= plural %> } from '<%= locations.dbSchemaServer.import %>';

@Injectable()
export class <%= className %>Repository
	extends BaseRepository<
		typeof <%= plural %>,
		<%= className %>,
		Create<%= className %>Input,
		Update<%= className %>Input
	>
	implements I<%= className %>Repository
{
	protected readonly table = <%= plural %>;

	// Behaviors declared in YAML -> generated as config object
	protected readonly behaviors: BehaviorConfig = {
		timestamps: <%= repositoryBehaviorConfig.timestamps %>,
		softDelete: <%= repositoryBehaviorConfig.softDelete %>,
		userTracking: <%= repositoryBehaviorConfig.userTracking %>,
	};

	protected toEntity(record: typeof <%= plural %>.$inferSelect): <%= className %> {
		return <%= className %>.fromRecord(record);
	}
<% belongsToRelations.forEach((rel) => { -%>

	async findBy<%= rel.foreignKeyPascal %>(id: string): Promise<<%= className %>[]> {
		const records = await this.baseQuery()
			.where(eq(this.table.<%= rel.foreignKeyCamel %>, id));
		return records.map((r) => this.toEntity(r));
	}
<% }) -%>
<% entityRefFields.forEach((ref) => { -%>

	async findBy<%= ref.pascalName %>(entityType: EntityType, entityId: string): Promise<<%= className %>[]> {
		const records = await this.baseQuery()
			.where(
				and(
					eq(this.table.<%= ref.camelName %>EntityType, entityType),
					eq(this.table.<%= ref.camelName %>EntityId, entityId)
				)
			);
		return records.map((r) => this.toEntity(r));
	}
<% }) -%>
<% if (hasRelationships) { -%>

	// ═══════════════════════════════════════════════════════════════════════
	// Relationship loading (extends base class)
	// ═══════════════════════════════════════════════════════════════════════

	async findByIdWithRelations(
		id: string,
		include?: <%= className %>With,
	): Promise<<%= className %> | null> {
		const record = await this.db.query.<%= plural %>.findFirst({
			where: eq(<%= plural %>.id, id),
			with: this.buildWithClause(include),
		});
		return record ? this.mapToEntityWithRelations(record) : null;
	}

	async findAllWithRelations(include?: <%= className %>With): Promise<<%= className %>[]> {
		const records = await this.db.query.<%= plural %>.findMany({
			with: this.buildWithClause(include),
		});
		return records.map((r) => this.mapToEntityWithRelations(r));
	}

	private buildWithClause(include?: <%= className %>With) {
		if (!include) return undefined;
		const result: Record<string, true> = {};
<% relationships.forEach((rel) => { -%>
		if (include.<%= rel.name %>) result.<%= rel.name %> = true;
<% }) -%>
		return Object.keys(result).length > 0 ? result : undefined;
	}

	// biome-ignore lint/suspicious/noExplicitAny: Drizzle relational query returns dynamic shape
	private mapToEntityWithRelations(record: any): <%= className %> {
<% if (hasExistingRelationships) { -%>
		return <%= className %>.fromRecord(record, (name, data) => {
			switch (name) {
<% existingBelongsTo.forEach((rel) => { -%>
				case '<%= rel.name %>':
					// biome-ignore lint/suspicious/noExplicitAny: Cast for Drizzle record
					return <%= rel.targetClass %>.fromRecord(data as any);
<% }) -%>
<% existingHasMany.forEach((rel) => { -%>
				case '<%= rel.name %>':
					// biome-ignore lint/suspicious/noExplicitAny: Cast for Drizzle records
					return (data as any[]).map((r) => <%= rel.targetClass %>.fromRecord(r));
<% }) -%>
<% existingHasOne.forEach((rel) => { -%>
				case '<%= rel.name %>':
					// biome-ignore lint/suspicious/noExplicitAny: Cast for Drizzle record
					return <%= rel.targetClass %>.fromRecord(data as any);
<% }) -%>
				default:
					return data;
			}
		});
<% } else { -%>
		// Related entities not yet generated - return entity without relationship mapping
		return <%= className %>.fromRecord(record);
<% } -%>
	}
<% } -%>
}
<% } else { -%>
<%# ================================================================== -%>
<%# INLINE STRATEGY - Full CRUD code generated directly                -%>
<%# ================================================================== -%>

import { Inject, Injectable } from '@nestjs/common';
import { eq<%= hasSoftDelete ? ', isNull, isNotNull' : '' %><%= hasEntityRefFields ? ', and' : '' %> } from 'drizzle-orm';
import { DRIZZLE } from '<%= imports.repositoryToConstants %>';
<% if (hasEntityRefFields) { -%>
import type { EntityType } from '<%= locations.dbSchemaServer.import %>';
<% } -%>
import type {
	Create<%= className %>Input,
	I<%= className %>Repository,
	Update<%= className %>Input,
<% if (hasRelationships) { -%>
	<%= className %>With,
<% } -%>
} from '../../../domain';
<%
// Collect unique entity imports - only include relationships with existing target entities
const entityImports = new Set([className]);
if (hasExistingRelationships) {
  [...existingBelongsTo, ...existingHasMany, ...existingHasOne].forEach((rel) => {
    entityImports.add(rel.targetClass);
  });
}
-%>
import { <%- [...entityImports].join(', ') %> } from '../../../domain';
import type { DrizzleDB } from '../database.module';
import { <%= plural %> } from '<%= locations.dbSchemaServer.import %>';

@Injectable()
export class <%= className %>Repository implements I<%= className %>Repository {
	constructor(@Inject(DRIZZLE) private readonly db: DrizzleDB) {}

	async create(input: Create<%= className %>Input): Promise<<%= className %>> {
<% if (hasTimestamps) { -%>
		const now = new Date();
<% } -%>
		const result = await this.db
			.insert(<%= plural %>)
			.values({
<% fields.forEach((field) => { -%>
				<%= field.camelName %>: input.<%= field.camelName %>,
<% }) -%>
<% if (hasTimestamps) { -%>
				createdAt: now,
				updatedAt: now,
<% } -%>
			})
			.returning();

		const record = result[0] as typeof <%= plural %>.$inferSelect;
		return <%= className %>.fromRecord(record);
	}

	async findById(id: string<%= hasRelationships ? `, include?: ${className}With` : '' %>): Promise<<%= className %> | null> {
<% if (hasRelationships) { -%>
		const record = await this.db.query.<%= plural %>.findFirst({
			where: eq(<%= plural %>.id, id),
			with: this.buildWithClause(include),
		});

		return record ? this.mapToEntity(record) : null;
<% } else { -%>
		const result = await this.baseQuery()
			.where(eq(<%= plural %>.id, id))
			.limit(1);

		const record = result[0];
		return record ? <%= className %>.fromRecord(record) : null;
<% } -%>
	}

	async findAll(<%= hasRelationships ? `include?: ${className}With` : '' %>): Promise<<%= className %>[]> {
<% if (hasRelationships) { -%>
		const records = await this.db.query.<%= plural %>.findMany({
			with: this.buildWithClause(include),
		});

		return records.map((r) => this.mapToEntity(r));
<% } else { -%>
		const records = await this.baseQuery();
		return records.map(<%= className %>.fromRecord);
<% } -%>
	}

	async update(id: string, input: Update<%= className %>Input): Promise<<%= className %> | null> {
		const result = await this.db
			.update(<%= plural %>)
			.set({
				...input,
<% if (hasTimestamps) { -%>
				updatedAt: new Date(),
<% } -%>
			})
			.where(eq(<%= plural %>.id, id))
			.returning();

		const record = result[0];
		return record ? <%= className %>.fromRecord(record) : null;
	}

	async delete(id: string): Promise<<%= className %> | null> {
<% if (hasSoftDelete) { -%>
		// Soft delete - set deletedAt timestamp
		const result = await this.db
			.update(<%= plural %>)
			.set({ deletedAt: new Date() })
			.where(eq(<%= plural %>.id, id))
			.returning();
<% } else { -%>
		const result = await this.db
			.delete(<%= plural %>)
			.where(eq(<%= plural %>.id, id))
			.returning();
<% } -%>

		const record = result[0];
		return record ? <%= className %>.fromRecord(record) : null;
	}
<% if (hasSoftDelete) { -%>

	async restore(id: string): Promise<<%= className %> | null> {
		const result = await this.db
			.update(<%= plural %>)
			.set({ deletedAt: null })
			.where(eq(<%= plural %>.id, id))
			.returning();

		const record = result[0];
		return record ? <%= className %>.fromRecord(record) : null;
	}

	async findWithDeleted(): Promise<<%= className %>[]> {
		const records = await this.db.select().from(<%= plural %>);
		return records.map(<%= className %>.fromRecord);
	}

	async findOnlyDeleted(): Promise<<%= className %>[]> {
		const records = await this.db
			.select()
			.from(<%= plural %>)
			.where(isNotNull(<%= plural %>.deletedAt));
		return records.map(<%= className %>.fromRecord);
	}
<% } -%>

	private baseQuery() {
<% if (hasSoftDelete) { -%>
		return this.db.select().from(<%= plural %>).where(isNull(<%= plural %>.deletedAt));
<% } else { -%>
		return this.db.select().from(<%= plural %>);
<% } -%>
	}
<% belongsToRelations.forEach((rel) => { -%>

	async findBy<%= rel.foreignKeyPascal %>(id: string<%= hasRelationships ? `, include?: ${className}With` : '' %>): Promise<<%= className %>[]> {
<% if (hasRelationships) { -%>
		const records = await this.db.query.<%= plural %>.findMany({
			where: eq(<%= plural %>.<%= rel.foreignKeyCamel %>, id),
			with: this.buildWithClause(include),
		});

		return records.map((r) => this.mapToEntity(r));
<% } else { -%>
		const records = await this.baseQuery()
			.where(eq(<%= plural %>.<%= rel.foreignKeyCamel %>, id));

		return records.map(<%= className %>.fromRecord);
<% } -%>
	}
<% }) -%>
<% entityRefFields.forEach((ref) => { -%>

	async findBy<%= ref.pascalName %>(entityType: EntityType, entityId: string<%= hasRelationships ? `, include?: ${className}With` : '' %>): Promise<<%= className %>[]> {
<% if (hasRelationships) { -%>
		const records = await this.db.query.<%= plural %>.findMany({
			where: and(
				eq(<%= plural %>.<%= ref.camelName %>EntityType, entityType),
				eq(<%= plural %>.<%= ref.camelName %>EntityId, entityId)
			),
			with: this.buildWithClause(include),
		});

		return records.map((r) => this.mapToEntity(r));
<% } else { -%>
		const records = await this.baseQuery()
			.where(
				and(
					eq(<%= plural %>.<%= ref.camelName %>EntityType, entityType),
					eq(<%= plural %>.<%= ref.camelName %>EntityId, entityId)
				)
			);

		return records.map(<%= className %>.fromRecord);
<% } -%>
	}
<% }) -%>
<% if (hasRelationships) { -%>

	private buildWithClause(include?: <%= className %>With) {
		if (!include) return undefined;
		// Drizzle expects `true` or object, not `false`. Only include truthy values.
		const result: Record<string, true> = {};
<% relationships.forEach((rel) => { -%>
		if (include.<%= rel.name %>) result.<%= rel.name %> = true;
<% }) -%>
		return Object.keys(result).length > 0 ? result : undefined;
	}

	// biome-ignore lint/suspicious/noExplicitAny: Drizzle relational query returns dynamic shape
	private mapToEntity(record: any): <%= className %> {
<% if (hasExistingRelationships) { -%>
		return <%= className %>.fromRecord(record, (name, data) => {
			switch (name) {
<% existingBelongsTo.forEach((rel) => { -%>
				case '<%= rel.name %>':
					// biome-ignore lint/suspicious/noExplicitAny: Cast for Drizzle record
					return <%= rel.targetClass %>.fromRecord(data as any);
<% }) -%>
<% existingHasMany.forEach((rel) => { -%>
				case '<%= rel.name %>':
					// biome-ignore lint/suspicious/noExplicitAny: Cast for Drizzle records
					return (data as any[]).map((r) => <%= rel.targetClass %>.fromRecord(r));
<% }) -%>
<% existingHasOne.forEach((rel) => { -%>
				case '<%= rel.name %>':
					// biome-ignore lint/suspicious/noExplicitAny: Cast for Drizzle record
					return <%= rel.targetClass %>.fromRecord(data as any);
<% }) -%>
				default:
					return data;
			}
		});
<% } else { -%>
		// Related entities not yet generated - return entity without relationship mapping
		return <%= className %>.fromRecord(record);
<% } -%>
	}
<% } -%>
}
<% } -%>
