---
to: <%= outputPaths.commandsGroupedIndex %>
force: true
---
<% if (outputPaths.commandsGroupedIndex) { -%>
/**
 * <%= className %> Commands Module
 * Generated by entity codegen - do not edit directly
 *
 * This file contains all command classes for <%= className %>
 * using grouped file layout (file_grouping: "grouped")
 */

import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { <%= repositoryToken %> } from '<%= imports.constants %>';
import type { Create<%= className %>Input, I<%= className %>Repository, Update<%= className %>Input } from '<%= imports.domain %>';
import { <%= className %> } from '<%= imports.domain %>';
import type { Create<%= className %>Dto, Update<%= className %>Dto } from '<%= imports.schemas %>';

// ============================================================================
// Create Command
// ============================================================================

/**
 * Create <%= className %> Command
 *
 * EXTENSION POINTS (add business logic here):
 * - Validation: Add domain validation rules before creating
 * - Defaults: Compute default values not handled by DTO
 * - Side effects: Emit events, send notifications, create related entities
 * - Authorization: Check user permissions beyond route-level auth
 * - Audit: Log creation for compliance/debugging
 */
@Injectable()
export class Create<%= className %>Command {
	constructor(
		@Inject(<%= repositoryToken %>)
		private readonly <%= camelName %>Repository: I<%= className %>Repository,
	) {}

	async execute(dto: Create<%= className %>Dto): Promise<<%= className %>> {
		// TODO: Add pre-create validation and business rules here

		// Map DTO to domain input
		const input: Create<%= className %>Input = {
<% fields.forEach((field) => { -%>
<% if (field.required) { -%>
			<%= field.camelName %>: dto.<%= field.camelName %>,
<% } else if (field.nullable) { -%>
			<%= field.camelName %>: dto.<%= field.camelName %> ?? null,
<% } else { -%>
			<%= field.camelName %>: dto.<%= field.camelName %>,
<% } -%>
<% }) -%>
		};

		const created = await this.<%= camelName %>Repository.create(input);

		// TODO: Add post-create side effects here (events, notifications, etc.)

		return created;
	}
}

// ============================================================================
// Update Command
// ============================================================================

/**
 * Update <%= className %> Command
 *
 * EXTENSION POINTS (add business logic here):
 * - Validation: Add domain validation rules (e.g., state transitions)
 * - Authorization: Check if user can modify this specific record
 * - Conflict detection: Optimistic locking, version checks
 * - Side effects: Emit events, invalidate caches, notify subscribers
 * - Audit: Log changes for compliance/debugging
 */
@Injectable()
export class Update<%= className %>Command {
	constructor(
		@Inject(<%= repositoryToken %>)
		private readonly <%= camelName %>Repository: I<%= className %>Repository,
	) {}

	async execute(id: string, dto: Update<%= className %>Dto): Promise<<%= className %>> {
		const existing = await this.<%= camelName %>Repository.findById(id);
		if (!existing) {
			throw new NotFoundException(`<%= className %> with id ${id} not found`);
		}

		// TODO: Add pre-update validation and business rules here
		// e.g., check state transitions, verify user permissions on this record

		// Map DTO to domain input (only include defined fields)
		const input: Update<%= className %>Input = {
<% fields.forEach((field) => { -%>
			...(dto.<%= field.camelName %> !== undefined && { <%= field.camelName %>: dto.<%= field.camelName %> }),
<% }) -%>
		};

		const updated = await this.<%= camelName %>Repository.update(id, input);
		if (!updated) {
			throw new NotFoundException(`<%= className %> with id ${id} not found`);
		}

		// TODO: Add post-update side effects here (events, cache invalidation, etc.)

		return updated;
	}
}

// ============================================================================
// Delete Command
// ============================================================================

/**
 * Delete <%= className %> Command
 *
 * EXTENSION POINTS (add business logic here):
 * - Authorization: Check if user can delete this specific record
 * - Referential integrity: Check for dependent records, cascade or block
 * - Soft delete: Mark as deleted instead of hard delete
 * - Side effects: Emit events, clean up related data, notify subscribers
 * - Audit: Log deletion for compliance/debugging
 */
@Injectable()
export class Delete<%= className %>Command {
	constructor(
		@Inject(<%= repositoryToken %>)
		private readonly <%= camelName %>Repository: I<%= className %>Repository,
	) {}

	async execute(id: string): Promise<<%= className %>> {
		// TODO: Add pre-delete validation here
		// e.g., check for dependent records, verify user permissions

		const deleted = await this.<%= camelName %>Repository.delete(id);
		if (!deleted) {
			throw new NotFoundException(`<%= className %> with id ${id} not found`);
		}

		// TODO: Add post-delete side effects here (events, cleanup, etc.)

		return deleted;
	}
}
<% } -%>
