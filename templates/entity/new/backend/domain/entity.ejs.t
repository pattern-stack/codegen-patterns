---
to: <%= outputPaths.entity %>
force: true
---
<% if (outputPaths.entity) { -%>
/**
 * <%= className %> Domain Entity
 * Generated by entity codegen - do not edit directly
 *
 * NOTE: Related entity imports assume a nested folder structure where each entity
 * lives in its own folder (e.g., domain/{entity}/{entity}.entity.ts). This follows
 * CLEAN architecture conventions where each aggregate root has its own bounded context.
 * All entities should follow this structure for consistent imports.
 */
<% if (hasEntityRefFields) { -%>
import type { EntityType } from '<%= locations.dbSchemaServer.import %>';
<% } -%>
<%
// Collect unique non-self-referential imports
const importedEntities = new Set();
[...belongsToRelations, ...hasManyRelations, ...hasOneRelations].forEach((rel) => {
  if (rel.target !== name) {
    importedEntities.add(rel.target);
  }
});
-%>
<% if (importedEntities.size > 0) { -%>

<% importedEntities.forEach((target) => {
  const targetClass = target.charAt(0).toUpperCase() + target.slice(1).replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import type { <%= targetClass %> } from '../<%= target %>/<%= target %>.entity';
<% }) -%>
<% } -%>

export class <%= className %> {
	constructor(
		public readonly id: string,
<% fields.forEach((field) => { -%>
		public readonly <%= field.camelName %>: <%- field.tsType %><%= field.nullable ? ' | null' : '' %>,
<% }) -%>
<% if (hasTimestamps) { -%>
		public readonly createdAt: Date,
		public readonly updatedAt: Date,
<% } -%>
<% if (hasSoftDelete) { -%>
		public readonly deletedAt: Date | null,
<% } -%>
<% if (hasTemporalValidity) { -%>
		public readonly validFrom: Date | null,
		public readonly validTo: Date | null,
		public readonly isActive: boolean,
<% } -%>
<% if (hasRelationships) { -%>
		// Loaded relations (optional, populated when eager-loaded)
<% belongsToRelations.forEach((rel) => { -%>
		public readonly <%= rel.name %>?: <%= rel.targetClass %>,
<% }) -%>
<% hasManyRelations.forEach((rel) => { -%>
		public readonly <%= rel.name %>?: <%= rel.targetClass %>[],
<% }) -%>
<% hasOneRelations.forEach((rel) => { -%>
		public readonly <%= rel.name %>?: <%= rel.targetClass %>,
<% }) -%>
<% } -%>
	) {}

	static fromRecord(
		// biome-ignore lint/suspicious/noExplicitAny: Drizzle records have dynamic shape
		record: Record<string, any>,
<% if (hasRelationships) { -%>
		// biome-ignore lint/suspicious/noExplicitAny: Returns different entity types
		mapRelation?: (name: string, data: unknown) => any,
<% } -%>
	): <%= className %> {
		return new <%= className %>(
			record.id,
<% fields.forEach((field) => { -%>
			record.<%= field.camelName %>,
<% }) -%>
<% if (hasTimestamps) { -%>
			record.createdAt,
			record.updatedAt,
<% } -%>
<% if (hasSoftDelete) { -%>
			record.deletedAt,
<% } -%>
<% if (hasTemporalValidity) { -%>
			record.validFrom,
			record.validTo,
			record.isActive,
<% } -%>
<% if (hasRelationships) { -%>
<% belongsToRelations.forEach((rel) => { -%>
			record.<%= rel.name %> ? mapRelation?.('<%= rel.name %>', record.<%= rel.name %>) : undefined,
<% }) -%>
<% hasManyRelations.forEach((rel) => { -%>
			record.<%= rel.name %> ? mapRelation?.('<%= rel.name %>', record.<%= rel.name %>) : undefined,
<% }) -%>
<% hasOneRelations.forEach((rel) => { -%>
			record.<%= rel.name %> ? mapRelation?.('<%= rel.name %>', record.<%= rel.name %>) : undefined,
<% }) -%>
<% } -%>
		);
	}
}
<% } -%>
