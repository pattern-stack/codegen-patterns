---
to: <%= outputPaths.domainGroupedIndex %>
force: true
---
<% if (outputPaths.domainGroupedIndex) { -%>
/**
 * <%= className %> Domain Module
 * Generated by entity codegen - do not edit directly
 *
 * This file contains the domain entity and repository interface
 * using grouped file layout (file_grouping: "grouped")
 */
<% if (hasEntityRefFields) { -%>
import type { EntityType } from '<%= locations.dbSchemaServer.import %>';
<% } -%>
<%
// Collect unique non-self-referential imports
const importedEntities = new Set();
[...belongsToRelations, ...hasManyRelations, ...hasOneRelations].forEach((rel) => {
  if (rel.target !== name) {
    importedEntities.add(rel.target);
  }
});
-%>
<% if (importedEntities.size > 0) { -%>

<% importedEntities.forEach((target) => {
  const targetClass = target.charAt(0).toUpperCase() + target.slice(1).replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import type { <%= targetClass %> } from '../<%= target %>';
<% }) -%>
<% } -%>

// ============================================================================
// Entity
// ============================================================================

export class <%= className %> {
	constructor(
		public readonly id: string,
<% fields.forEach((field) => { -%>
		public readonly <%= field.camelName %>: <%- field.tsType %><%= field.nullable ? ' | null' : '' %>,
<% }) -%>
<% if (hasTimestamps) { -%>
		public readonly createdAt: Date,
		public readonly updatedAt: Date,
<% } -%>
<% if (hasSoftDelete) { -%>
		public readonly deletedAt: Date | null,
<% } -%>
<% if (hasTemporalValidity) { -%>
		public readonly validFrom: Date | null,
		public readonly validTo: Date | null,
		public readonly isActive: boolean,
<% } -%>
<% if (hasRelationships) { -%>
		// Loaded relations (optional, populated when eager-loaded)
<% belongsToRelations.forEach((rel) => { -%>
		public readonly <%= rel.name %>?: <%= rel.targetClass %>,
<% }) -%>
<% hasManyRelations.forEach((rel) => { -%>
		public readonly <%= rel.name %>?: <%= rel.targetClass %>[],
<% }) -%>
<% hasOneRelations.forEach((rel) => { -%>
		public readonly <%= rel.name %>?: <%= rel.targetClass %>,
<% }) -%>
<% } -%>
	) {}

	static fromRecord(
		// biome-ignore lint/suspicious/noExplicitAny: Drizzle records have dynamic shape
		record: Record<string, any>,
<% if (hasRelationships) { -%>
		// biome-ignore lint/suspicious/noExplicitAny: Returns different entity types
		mapRelation?: (name: string, data: unknown) => any,
<% } -%>
	): <%= className %> {
		return new <%= className %>(
			record.id,
<% fields.forEach((field) => { -%>
			record.<%= field.camelName %>,
<% }) -%>
<% if (hasTimestamps) { -%>
			record.createdAt,
			record.updatedAt,
<% } -%>
<% if (hasSoftDelete) { -%>
			record.deletedAt,
<% } -%>
<% if (hasTemporalValidity) { -%>
			record.validFrom,
			record.validTo,
			record.isActive,
<% } -%>
<% if (hasRelationships) { -%>
<% belongsToRelations.forEach((rel) => { -%>
			record.<%= rel.name %> ? mapRelation?.('<%= rel.name %>', record.<%= rel.name %>) : undefined,
<% }) -%>
<% hasManyRelations.forEach((rel) => { -%>
			record.<%= rel.name %> ? mapRelation?.('<%= rel.name %>', record.<%= rel.name %>) : undefined,
<% }) -%>
<% hasOneRelations.forEach((rel) => { -%>
			record.<%= rel.name %> ? mapRelation?.('<%= rel.name %>', record.<%= rel.name %>) : undefined,
<% }) -%>
<% } -%>
		);
	}
}

// ============================================================================
// Repository Interface
// ============================================================================
<% if (hasRelationships) { -%>

/**
 * Type-safe eager loading options.
 * Pass to repository methods to include related entities.
 */
export type <%= className %>With = {
<% relationships.forEach((rel) => { -%>
	<%= rel.name %>?: boolean;
<% }) -%>
};
<% } -%>

/**
 * Domain-level input types for repository operations.
 */
export type Create<%= className %>Input = {
<% fields.forEach((field) => { -%>
<% if (field.required) { -%>
	<%= field.camelName %>: <%- field.tsType %>;
<% } else if (field.nullable) { -%>
	<%= field.camelName %>?: <%- field.tsType %> | null;
<% } else { -%>
	<%= field.camelName %>?: <%- field.tsType %>;
<% } -%>
<% }) -%>
};

export type Update<%= className %>Input = Partial<Create<%= className %>Input>;

export interface I<%= className %>Repository {
	create(input: Create<%= className %>Input): Promise<<%= className %>>;
	findById(id: string<%= hasRelationships ? `, include?: ${className}With` : '' %>): Promise<<%= className %> | null>;
	findAll(<%= hasRelationships ? `include?: ${className}With` : '' %>): Promise<<%= className %>[]>;
	update(id: string, input: Update<%= className %>Input): Promise<<%= className %> | null>;
	delete(id: string): Promise<<%= className %> | null>;
<% if (hasSoftDelete) { -%>
	// Soft delete recovery methods
	restore(id: string): Promise<<%= className %> | null>;
	findWithDeleted(): Promise<<%= className %>[]>;
	findOnlyDeleted(): Promise<<%= className %>[]>;
<% } -%>
<% belongsToRelations.forEach((rel) => { -%>
	findBy<%= rel.foreignKeyPascal %>(id: string<%= hasRelationships ? `, include?: ${className}With` : '' %>): Promise<<%= className %>[]>;
<% }) -%>
<% entityRefFields.forEach((ref) => { -%>
	findBy<%= ref.pascalName %>(entityType: EntityType, entityId: string<%= hasRelationships ? `, include?: ${className}With` : '' %>): Promise<<%= className %>[]>;
<% }) -%>
}
<% } -%>
