---
to: "<%= generate.structure === 'entity-first' ? `${locations.frontendGenerated.path}/${generate.fileNaming === 'plural' ? plural : name}/types.ts` : generate.structure === 'concern-first' ? `${locations.frontendGenerated.path}/types/${generate.fileNaming === 'plural' ? plural : name}.ts` : '' %>"
skip_if: <%= generate.structure === 'monolithic' %>
force: true
---
/**
 * <%= className %> Types
 * Generated by entity codegen - do not edit directly
 *
 * Type definitions for <%= className %> entity with resolved relations
 */

<%
// Type import: depends on typeNaming config
// 'entity' = source exports OpportunityEntity, 'plain' = source exports Opportunity
const importedTypeName = generate.typeNaming === 'plain' ? className : className + 'Entity';
// Collect unique belongs_to targets for imports (FK resolution)
// Only import if fkResolution is enabled (default: true)
const importedEntities = new Set();
if (generate.fkResolution !== false) {
  existingBelongsTo.forEach((rel) => {
    if (rel.target !== name) {
      importedEntities.add(rel.target);
    }
  });
}
-%>
import type { <%= importedTypeName %> } from '<%= locations.dbEntities.import %><% if (!locations.dbEntities.barrelExport) { %>/<%= name %><% } %>';
<% if (importedEntities.size > 0) { -%>

// Import related entity types for FK resolution
<% importedEntities.forEach((target) => {
  const targetClass = target.charAt(0).toUpperCase() + target.slice(1).replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import type { <%= generate.typeNaming === 'plain' ? targetClass : targetClass + 'Entity' %> } from '<%= locations.dbEntities.import %><% if (!locations.dbEntities.barrelExport) { %>/<%= target %><% } %>';
<% }); -%>
<% } -%>

/** Base entity from database */
<% if (generate.typeNaming === 'plain') { -%>
export type { <%= className %> };
<% } else { -%>
export type <%= className %> = <%= importedTypeName %>;
<% } -%>
<% if (existingBelongsTo.length > 0 && generate.fkResolution !== false) { -%>

/** Entity with resolved FK relations (only includes relations with existing targets) */
export interface <%= className %>Resolved extends <%= className %> {
<% existingBelongsTo.forEach((rel) => { -%>
<% // Use local type for self-referential, imported type for others -%>
<%   const relTypeName = rel.target === name ? className : (generate.typeNaming === 'plain' ? rel.targetClass : rel.targetClass + 'Entity'); -%>
	<%= rel.name %>?: <%= relTypeName %>;
<% }); -%>
}
<% } else { -%>

/** Entity type (no FK relations to resolve) */
export type <%= className %>Resolved = <%= className %>;
<% } -%>
