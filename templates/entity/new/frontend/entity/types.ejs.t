---
to: "<%= generate.structure === 'entity-first' ? `${locations.frontendGenerated.path}/${name}/types.ts` : generate.structure === 'concern-first' ? `${locations.frontendGenerated.path}/types/${name}.ts` : '' %>"
skip_if: <%= generate.structure === 'monolithic' %>
force: true
---
/**
 * <%= className %> Types
 * Generated by entity codegen - do not edit directly
 *
 * Type definitions for <%= className %> entity with resolved relations
 */

import { <%= camelName %>Schema, type <%= className %>Entity } from '<%= locations.dbEntities.import %><% if (!locations.dbEntities.barrelExport) { %>/<%= name %><% } %>';
<% if (existingBelongsTo.length > 0) { -%>
<%
// Import related entity types for FK resolution
const importedEntities = new Set();
existingBelongsTo.forEach((rel) => {
  if (rel.target !== name) {
    importedEntities.add(rel.target);
  }
});
-%>
<% if (importedEntities.size > 0) { -%>

// Import related entity types for FK resolution
<% importedEntities.forEach((target) => {
  const targetClass = target.charAt(0).toUpperCase() + target.slice(1).replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import type { <%= targetClass %>Entity } from '<%= locations.dbEntities.import %><% if (!locations.dbEntities.barrelExport) { %>/<%= target %><% } %>';
<% }); -%>
<% } -%>
<% } -%>

/** Base entity from database */
export type <%= className %> = <%= className %>Entity;
<% if (existingBelongsTo.length > 0) { -%>

/** Entity with resolved FK relations (only includes relations with existing targets) */
export interface <%= className %>Resolved extends <%= className %> {
<% existingBelongsTo.forEach((rel) => { -%>
<% // Use local type for self-referential, imported type for others -%>
	<%= rel.name %>?: <%= rel.target === name ? className : rel.targetClass + 'Entity' %>;
<% }); -%>
}
<% } else { -%>

/** Entity type (no FK relations to resolve) */
export type <%= className %>Resolved = <%= className %>;
<% } -%>
