---
to: "<%= generate.structure === 'monolithic' ? `${locations.frontendGenerated.path}/${generate.fileNaming === 'plural' ? plural : name}.ts` : '' %>"
skip_if: <%= generate.structure !== 'monolithic' %>
force: true
---
/**
 * <%= className %> - Generated Entity Module
 *
 * AUTO-GENERATED by entity codegen - do not edit directly.
 * Source: entities/<%= name %>.yaml
 *
 * This file contains everything needed for the <%= className %> entity:
 * - Types (base + resolved with relations)
 * - Collection (Electric sync with optimistic mutations)
 * - Hooks (useMany, useOne with auto-resolved relations)
 * - Mutations (insert, update, delete)
 * - Field metadata (for DataGrid, forms, admin)
 */

<%
// Type import depends on typeNaming config - source exports {ClassName}Entity
const importedTypeName = className + 'Entity';
// Collection variable name depends on collectionNaming config
const collectionVar = generate.collectionNaming === 'plural' ? collectionVarNamePlural : collectionVarName;
// Hook return key depends on hookReturnStyle config
const returnKey = generate.hookReturnStyle === 'named' ? pluralCamelName : 'data';
const returnKeySingular = generate.hookReturnStyle === 'named' ? camelName : 'data';
-%>
<% if (frontend.sync.columnMapper) { -%>
import { <%= frontend.sync.columnMapper %> } from '@electric-sql/client';
<% } -%>
import { <%= camelName %>Schema, type <%= importedTypeName %> } from '<%= locations.dbEntities.import %><% if (!locations.dbEntities.barrelExport) { %>/<%= name %><% } %>';
<% if (exposeTrpc) { -%>
import { trpc } from '<%= locations.trpcClient.import %>';
<% } -%>
import { electricCollectionOptions } from '@tanstack/electric-db-collection';
import { createCollection<% if (generate.hookStyle === 'useLiveQuery') { %>, useLiveQuery, eq<% } %> } from '@tanstack/react-db';
<% if (generate.fieldMetadata) { -%>
import type { FieldMeta, FieldType, FieldImportance } from '<%= locations.frontendFieldMetaTypes.import %>/field-meta';
<% } -%>
<% if (frontend.auth.function) { -%>
import { <%= frontend.auth.function %> } from '<%= locations.frontendCollectionsAuth.import %>';
<% } -%>
<% if (frontend.sync.apiBaseUrlImport) { -%>
import { API_BASE_URL } from '<%= frontend.sync.apiBaseUrlImport %>';
<% } -%>
<%
// Collect unique belongs_to targets for imports (FK resolution)
// Only import if fkResolution is enabled (default: true)
const importedEntities = new Set();
if (generate.fkResolution !== false) {
  existingBelongsTo.forEach((rel) => {
    if (rel.target !== name) {
      importedEntities.add(rel.target);
    }
  });
}
-%>
<% if (importedEntities.size > 0) { -%>

// Import related collections for FK resolution
<% importedEntities.forEach((target) => {
  const targetCamel = target.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
  // Simple pluralization matching prompt.js pluralize function
  const targetPlural = target.endsWith('y') ? target.slice(0, -1) + 'ies' :
    (target.endsWith('s') || target.endsWith('x') || target.endsWith('ch') || target.endsWith('sh')) ? target + 'es' : target + 's';
  const targetFileName = generate.fileNaming === 'plural' ? targetPlural : target;
  const targetCamelPlural = targetCamel.endsWith('y') ? targetCamel.slice(0, -1) + 'ies' : targetCamel + 's';
  const targetCollectionVar = generate.collectionNaming === 'plural' ? targetCamelPlural : targetCamel;
-%>
import { <%= targetCollectionVar %>Collection } from './<%= targetFileName %>';
<% }); -%>
<% importedEntities.forEach((target) => {
  const targetClass = target.charAt(0).toUpperCase() + target.slice(1).replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import type { <%= targetClass %>Entity } from '<%= locations.dbEntities.import %><% if (!locations.dbEntities.barrelExport) { %>/<%= target %><% } %>';
<% }); -%>
<% } -%>

// ============================================================================
// Types
// ============================================================================

/** Base entity from database */
export type <%= className %> = <%= importedTypeName %>;
<% if (existingBelongsTo.length > 0) { -%>

/** Entity with resolved FK relations (only includes relations with existing targets) */
export interface <%= className %>Resolved extends <%= className %> {
<% existingBelongsTo.forEach((rel) => { -%>
<% // Use local type for self-referential, imported type for others -%>
<%   const relTypeName = rel.target === name ? className : (generate.typeNaming === 'plain' ? rel.targetClass : rel.targetClass + 'Entity'); -%>
	<%= rel.name %>?: <%= relTypeName %>;
<% }); -%>
}
<% } else { -%>

/** Entity type (no FK relations to resolve) */
export type <%= className %>Resolved = <%= className %>;
<% } -%>

// ============================================================================
// Collection (Electric sync with optimistic mutations)
// ============================================================================
<% if (hasSoftDelete) { -%>

// TODO: Backend Electric shape endpoint should filter soft-deleted records
// by including WHERE deleted_at IS NULL in the shape configuration.
// Without this filter, soft-deleted records will reappear after Electric sync.
<% } -%>

export const <%= collectionVar %> = createCollection(
	electricCollectionOptions({
		id: '<%= plural %>',
		shapeOptions: {
<% if (frontend.sync.useTableParam) { -%>
<% if (frontend.sync.wrapInUrlConstructor !== false) { -%>
			url: new URL(
				'<%= frontend.sync.shapeUrl %>',
				typeof window !== 'undefined'
					? window.location.origin
					: 'http://localhost:5173',
			).toString(),
<% } else { -%>
			url: '<%= frontend.sync.shapeUrl %>',
<% } -%>
			params: {
				table: '<%= plural %>',
			},
<% } else { -%>
<% if (frontend.sync.wrapInUrlConstructor !== false) { -%>
			url: new URL(
				`<%= frontend.sync.shapeUrl %>/<%= plural %>`,
				typeof window !== 'undefined'
					? window.location.origin
					: 'http://localhost:5173',
			).toString(),
<% } else { -%>
			url: `<%= frontend.sync.shapeUrl %>/<%= plural %>`,
<% } -%>
<% } -%>
<% if (frontend.auth.function) { -%>
			headers: {
				Authorization: <%= frontend.auth.function %>(),
			},
<% } -%>
			parser: {
<% Object.entries(frontend.parsers).forEach(([type, fn]) => { -%>
				<%- type %>: <%- fn %>,
<% }); -%>
			},
<% if (frontend.sync.columnMapper) { -%>
<% if (frontend.sync.columnMapperNeedsCall !== false) { -%>
			columnMapper: <%= frontend.sync.columnMapper %>(),
<% } else { -%>
			columnMapper: <%= frontend.sync.columnMapper %>,
<% } -%>
<% } -%>
		},
		schema: <%= camelName %>Schema,
		getKey: (item) => item.id,
<% if (generate.mutations && (exposeTrpc || exposeRepository)) { -%>
<% if (exposeTrpc) { -%>
		onInsert: async ({ transaction }) => {
			const { modified } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.create.mutate(modified);
			return { txid: result.txid };
		},
		onUpdate: async ({ transaction }) => {
			const { modified } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.update.mutate({ id: modified.id, data: modified });
			return { txid: result.txid };
		},
		onDelete: async ({ transaction }) => {
			const { original } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.delete.mutate({ id: original.id });
			return { txid: result.txid };
		},
<% } -%>
<% } -%>
	}),
);

// ============================================================================
// Resolution (FK lookup - internal use)
// ============================================================================
<% if (existingBelongsTo.length > 0 && generate.fkResolution !== false) { -%>

function resolveRelations(entity: <%= className %>): <%= className %>Resolved {
	return {
		...entity,
<% existingBelongsTo.forEach((rel) => {
  const targetCamel = rel.target.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
  const targetCamelPlural = targetCamel.endsWith('y') ? targetCamel.slice(0, -1) + 'ies' : targetCamel + 's';
  const targetCollectionVar = generate.collectionNaming === 'plural' ? targetCamelPlural : targetCamel;
-%>
		<%= rel.name %>: entity.<%= rel.foreignKeyCamel %>
			? <%= targetCollectionVar %>Collection.state.get(entity.<%= rel.foreignKeyCamel %>)
			: undefined,
<% }); -%>
	};
}
<% } else { -%>

function resolveRelations(entity: <%= className %>): <%= className %>Resolved {
	return entity;
}
<% } -%>

// ============================================================================
// Hooks (React hooks returning resolved entities)
// ============================================================================
<% if (generate.hookStyle === 'useLiveQuery') { -%>

/** Get all <%= plural %> with relations resolved */
export function use<%= classNamePlural %>() {
	const result = useLiveQuery((q) => q.from({ <%= collectionVar %> }), []);
	return {
		<%= returnKey %>: result.data?.map(resolveRelations) ?? [],
		isLoading: result.isLoading,
	};
}

/** Get single <%= camelName %> by ID with relations resolved */
export function use<%= className %>(id: string | undefined) {
	const result = useLiveQuery(
		(q) => {
			if (!id) return undefined;
			return q
				.from({ <%= collectionVar %> })
				.where(({ <%= collectionVar %> }) => eq(<%= collectionVar %>.id, id));
		},
		[id],
	);
	const entity = result.data?.[0];
	return {
		<%= returnKeySingular %>: entity ? resolveRelations(entity) : undefined,
		isLoading: result.isLoading,
	};
}
<% } else { -%>

/** Get all <%= plural %> with relations resolved */
export function use<%= classNamePlural %>(): <%= className %>Resolved[] {
	const raw = <%= collectionVar %>.useMany();
	return raw.map(resolveRelations);
}

/** Get single <%= camelName %> by ID with relations resolved */
export function use<%= className %>(id: string | undefined): <%= className %>Resolved | undefined {
	const raw = <%= collectionVar %>.useOne(id);
	return raw ? resolveRelations(raw) : undefined;
}
<% } -%>

<% if (generate.mutations && (exposeTrpc || exposeRepository)) { -%>
// ============================================================================
// Mutations (Optimistic updates)
// ============================================================================

export function insert<%= className %>(data: Omit<<%= className %>, 'id'<% if (hasTimestamps) { %> | 'createdAt' | 'updatedAt'<% } %>>) {
	return <%= collectionVar %>.insert({
		id: crypto.randomUUID(),
<% if (hasTimestamps) { -%>
		createdAt: new Date(),
		updatedAt: new Date(),
<% } -%>
		...data,
	} as <%= className %>);
}

export function update<%= className %>(id: string, fn: (draft: <%= className %>) => void) {
	return <%= collectionVar %>.update(id, fn);
}

export function delete<%= className %>(id: string) {
	return <%= collectionVar %>.delete(id);
}
<% } -%>
<% if (generate.fieldMetadata) { -%>

// ============================================================================
// Field Metadata (for DataGrid, forms, admin)
// ============================================================================

export const <%= camelName %>Fields: Record<string, FieldMeta<<%= className %>Resolved>> = {
<% fields.forEach((field) => { -%>
<% // Skip entity ref internal fields from metadata display
if (field.isEntityRefType || field.isEntityRefId) return;
-%>
	<%= field.camelName %>: {
		field: '<%= field.camelName %>',
		label: '<%= field.ui_label %>',
		type: '<%= field.ui_type %>' as FieldType,
		importance: '<%= field.ui_importance %>' as FieldImportance,
<% if (field.ui_sortable) { -%>
		sortable: true,
<% } -%>
<% if (field.ui_filterable) { -%>
		filterable: true,
<% } -%>
<% if (field.ui_format) { -%>
		format: <%- JSON.stringify(field.ui_format) %>,
<% } -%>
<% if (field.hasChoices) { -%>
		choices: <%- JSON.stringify(field.choices) %>,
<% } -%>
<% if (field.foreignKey) { -%>
		reference: '<%= field.foreignKey.split('.')[0] %>',
<% } -%>
	},
<% }); -%>
<% // Add resolved relation fields to metadata
belongsToRelations.forEach((rel) => { -%>
	<%= rel.name %>: {
		field: '<%= rel.name %>',
		label: '<%= rel.targetClass.replace(/([A-Z])/g, ' $1').trim() %>',
		type: 'entity' as FieldType,
		importance: 'secondary' as FieldImportance,
		reference: '<%= rel.targetPlural %>',
	},
<% }); -%>
<% if (hasTimestamps) { -%>
	createdAt: {
		field: 'createdAt',
		label: 'Created',
		type: 'datetime' as FieldType,
		importance: 'tertiary' as FieldImportance,
		format: { dateFormat: 'relative' },
	},
	updatedAt: {
		field: 'updatedAt',
		label: 'Updated',
		type: 'datetime' as FieldType,
		importance: 'tertiary' as FieldImportance,
		format: { dateFormat: 'relative' },
	},
<% } -%>
};

export const <%= camelName %>Metadata = {
	name: '<%= name %>',
	plural: '<%= plural %>',
	displayName: '<%= className.replace(/([A-Z])/g, ' $1').trim() %>',
	displayNamePlural: '<%= classNamePlural.replace(/([A-Z])/g, ' $1').trim() %>',

	fields: <%= camelName %>Fields,

	// Display configuration
	primaryFields: [
<% fields.filter(f => f.ui_importance === 'primary').forEach(f => { -%>
		'<%= f.camelName %>',
<% }); -%>
	],
	searchFields: [
<% fields.filter(f => f.ui_filterable).forEach(f => { -%>
		'<%= f.camelName %>',
<% }); -%>
	],
	defaultSort: { field: '<% if (hasTimestamps) { %>createdAt<% } else { %>id<% } %>', direction: 'desc' as const },

	// Capabilities
	capabilities: {
		create: <%= exposeRepository || exposeTrpc %>,
		update: <%= exposeRepository || exposeTrpc %>,
		delete: <%= exposeRepository || exposeTrpc %>,
		list: true,
		get: true,
	},
} as const;
<% } -%>

// ============================================================================
// Export bundle for registry
// ============================================================================

export const <%= camelName %> = {
	// Collection
	collection: <%= collectionVar %>,

	// Hooks
	useMany: use<%= classNamePlural %>,
	useOne: use<%= className %>,
<% if (generate.mutations && (exposeTrpc || exposeRepository)) { -%>

	// Mutations
	insert: insert<%= className %>,
	update: update<%= className %>,
	delete: delete<%= className %>,
<% } -%>
<% if (generate.fieldMetadata) { -%>

	// Metadata
	fields: <%= camelName %>Fields,
	metadata: <%= camelName %>Metadata,
<% } -%>
} as const;
