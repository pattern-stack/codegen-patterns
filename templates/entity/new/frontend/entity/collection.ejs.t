---
to: "<%= generate.structure === 'entity-first' ? `${locations.frontendGenerated.path}/${name}/collection.ts` : generate.structure === 'concern-first' ? `${locations.frontendGenerated.path}/collections/${name}.ts` : '' %>"
skip_if: <%= generate.structure === 'monolithic' %>
force: true
---
/**
 * <%= className %> Collection
 * Generated by entity codegen - do not edit directly
 *
 * Real-time synced collection using Electric SQL
 */

<% if (frontend.sync.columnMapper) { -%>
import { <%= frontend.sync.columnMapper %> } from '@electric-sql/client';
<% } -%>
import { <%= camelName %>Schema } from '<%= locations.dbEntities.import %><% if (!locations.dbEntities.barrelExport) { %>/<%= name %><% } %>';
<% if (exposeTrpc) { -%>
import { trpc } from '<%= locations.trpcClient.import %>';
<% } -%>
import { electricCollectionOptions } from '@tanstack/electric-db-collection';
import { createCollection } from '@tanstack/react-db';
<% if (frontend.auth.function) { -%>
import { <%= frontend.auth.function %> } from '<%= locations.frontendCollectionsAuth.import %>';
<% } -%>
<% if (frontend.sync.apiBaseUrlImport) { -%>
import { API_BASE_URL } from '<%= frontend.sync.apiBaseUrlImport %>';
<% } -%>
<% if (hasSoftDelete) { -%>

// TODO: Backend Electric shape endpoint should filter soft-deleted records
// by including WHERE deleted_at IS NULL in the shape configuration.
// Without this filter, soft-deleted records will reappear after Electric sync.
<% } -%>

export const <%= camelName %>Collection = createCollection(
	electricCollectionOptions({
		id: '<%= plural %>',
		shapeOptions: {
<% if (frontend.sync.useTableParam) { -%>
<% if (frontend.sync.wrapInUrlConstructor !== false) { -%>
			url: new URL(
				'<%= frontend.sync.shapeUrl %>',
				typeof window !== 'undefined'
					? window.location.origin
					: 'http://localhost:5173',
			).toString(),
<% } else { -%>
			url: '<%= frontend.sync.shapeUrl %>',
<% } -%>
			params: {
				table: '<%= plural %>',
			},
<% } else { -%>
			url: `<%= frontend.sync.shapeUrl %>/<%= plural %>`,
<% } -%>
<% if (frontend.auth.function) { -%>
			headers: {
				Authorization: <%= frontend.auth.function %>(),
			},
<% } -%>
			parser: {
<% Object.entries(frontend.parsers).forEach(([type, fn]) => { -%>
				<%- type %>: <%- fn %>,
<% }); -%>
			},
<% if (frontend.sync.columnMapper) { -%>
<% if (frontend.sync.columnMapperNeedsCall !== false) { -%>
			columnMapper: <%= frontend.sync.columnMapper %>(),
<% } else { -%>
			columnMapper: <%= frontend.sync.columnMapper %>,
<% } -%>
<% } -%>
		},
		schema: <%= camelName %>Schema,
		getKey: (item) => item.id,
<% if (generate.mutations && (exposeTrpc || exposeRepository)) { -%>
<% if (exposeTrpc) { -%>
		onInsert: async ({ transaction }) => {
			const { modified } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.create.mutate(modified);
			return { txid: result.txid };
		},
		onUpdate: async ({ transaction }) => {
			const { modified } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.update.mutate({ id: modified.id, data: modified });
			return { txid: result.txid };
		},
		onDelete: async ({ transaction }) => {
			const { original } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.delete.mutate({ id: original.id });
			return { txid: result.txid };
		},
<% } -%>
<% } -%>
	}),
);
<%
// Collect unique belongs_to targets for imports (FK resolution)
const importedEntities = new Set();
existingBelongsTo.forEach((rel) => {
  if (rel.target !== name) {
    importedEntities.add(rel.target);
  }
});
-%>
<% if (importedEntities.size > 0) { -%>

// Import related collections for FK resolution
<% importedEntities.forEach((target) => {
  const targetCamel = target.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import { <%= targetCamel %>Collection } from '<% if (generate.structure === 'entity-first') { %>./<%= target %>/collection<% } else { %>./<%= target %><% } %>';
<% }); -%>
<% } -%>
<% if (generate.structure === 'entity-first') { -%>

// Import types from sibling module
import type { <%= className %>, <%= className %>Resolved } from './types';
<% } else { -%>

// Import types
import type { <%= className %>, <%= className %>Resolved } from '<% if (generate.structure === 'concern-first') { %>../types/<%= name %><% } %>';
<% } -%>

// ============================================================================
// Resolution (FK lookup - internal use)
// ============================================================================
<% if (existingBelongsTo.length > 0) { -%>

export function resolveRelations(entity: <%= className %>): <%= className %>Resolved {
	return {
		...entity,
<% existingBelongsTo.forEach((rel) => { -%>
		<%= rel.name %>: entity.<%= rel.foreignKeyCamel %>
			? <%= rel.target.replace(/_([a-z])/g, (_, c) => c.toUpperCase()) %>Collection.state.get(entity.<%= rel.foreignKeyCamel %>)
			: undefined,
<% }); -%>
	};
}
<% } else { -%>

export function resolveRelations(entity: <%= className %>): <%= className %>Resolved {
	return entity;
}
<% } -%>
