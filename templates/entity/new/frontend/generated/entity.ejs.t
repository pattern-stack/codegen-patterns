---
to: apps/frontend/src/generated/<%= name %>.ts
force: true
---
/**
 * <%= className %> - Generated Entity Module
 *
 * AUTO-GENERATED by entity codegen - do not edit directly.
 * Source: entities/<%= name %>.yaml
 *
 * This file contains everything needed for the <%= className %> entity:
 * - Types (base + resolved with relations)
 * - Collection (Electric sync with optimistic mutations)
 * - Hooks (useMany, useOne with auto-resolved relations)
 * - Mutations (insert, update, delete)
 * - Field metadata (for DataGrid, forms, admin)
 */

import { <%= camelName %>Schema, type <%= className %>Entity } from '@repo/db/entities/<%= name %>';
import { trpc } from '@repo/trpc/client';
import { electricCollectionOptions } from '@tanstack/electric-db-collection';
import { createCollection } from '@tanstack/react-db';
import type { FieldMeta, FieldType, FieldImportance } from '@/lib/types/field-meta';
import { getAuthorizationHeader } from '@/lib/collections/auth';
<%
// Collect unique belongs_to targets for imports (FK resolution)
const importedEntities = new Set();
belongsToRelations.forEach((rel) => {
  if (rel.target !== name) {
    importedEntities.add(rel.target);
  }
});
-%>
<% if (importedEntities.size > 0) { -%>

// Import related collections for FK resolution
<% importedEntities.forEach((target) => {
  const targetCamel = target.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import { <%= targetCamel %>Collection } from './<%= target %>';
<% }); -%>
<% if (importedEntities.size > 0) { -%>
<% importedEntities.forEach((target) => {
  const targetClass = target.charAt(0).toUpperCase() + target.slice(1).replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import type { <%= targetClass %>Entity } from '@repo/db/entities/<%= target %>';
<% }); -%>
<% } -%>
<% } -%>

// ============================================================================
// Types
// ============================================================================

/** Base entity from database */
export type <%= className %> = <%= className %>Entity;
<% if (belongsToRelations.length > 0) { -%>

/** Entity with resolved FK relations */
export interface <%= className %>Resolved extends <%= className %> {
<% belongsToRelations.forEach((rel) => { -%>
<% // Use local type for self-referential, imported type for others -%>
	<%= rel.name %>?: <%= rel.target === name ? className : rel.targetClass + 'Entity' %>;
<% }); -%>
}
<% } else { -%>

/** Entity type (no FK relations to resolve) */
export type <%= className %>Resolved = <%= className %>;
<% } -%>

// ============================================================================
// Collection (Electric sync with optimistic mutations)
// ============================================================================
<% if (hasSoftDelete) { -%>

// TODO: Backend Electric shape endpoint should filter soft-deleted records
// by including WHERE deleted_at IS NULL in the shape configuration.
// Without this filter, soft-deleted records will reappear after Electric sync.
<% } -%>

export const <%= camelName %>Collection = createCollection(
	electricCollectionOptions({
		id: '<%= plural %>',
		shapeOptions: {
			url: new URL(
				'/v1/shape',
				typeof window !== 'undefined'
					? window.location.origin
					: 'http://localhost:5173',
			).toString(),
			params: {
				table: '<%= plural %>',
			},
			headers: {
				Authorization: getAuthorizationHeader,
			},
			parser: {
				timestamptz: (date: string) => new Date(date),
			},
		},
		schema: <%= camelName %>Schema,
		getKey: (item) => item.id,
<% if (exposeTrpc) { -%>
		onInsert: async ({ transaction }) => {
			const { modified } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.create.mutate(modified);
			return { txid: result.txid };
		},
		onUpdate: async ({ transaction }) => {
			const { modified } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.update.mutate({ id: modified.id, data: modified });
			return { txid: result.txid };
		},
		onDelete: async ({ transaction }) => {
			const { original } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.delete.mutate({ id: original.id });
			return { txid: result.txid };
		},
<% } -%>
	}),
);

// ============================================================================
// Resolution (FK lookup - internal use)
// ============================================================================
<% if (belongsToRelations.length > 0) { -%>

function resolveRelations(entity: <%= className %>): <%= className %>Resolved {
	return {
		...entity,
<% belongsToRelations.forEach((rel) => { -%>
		<%= rel.name %>: entity.<%= rel.foreignKeyCamel %>
			? <%= rel.target.replace(/_([a-z])/g, (_, c) => c.toUpperCase()) %>Collection.state.get(entity.<%= rel.foreignKeyCamel %>)
			: undefined,
<% }); -%>
	};
}
<% } else { -%>

function resolveRelations(entity: <%= className %>): <%= className %>Resolved {
	return entity;
}
<% } -%>

// ============================================================================
// Hooks (React hooks returning resolved entities)
// ============================================================================

/** Get all <%= plural %> with relations resolved */
export function use<%= classNamePlural %>(): <%= className %>Resolved[] {
	const raw = <%= camelName %>Collection.useMany();
	return raw.map(resolveRelations);
}

/** Get single <%= camelName %> by ID with relations resolved */
export function use<%= className %>(id: string | undefined): <%= className %>Resolved | undefined {
	const raw = <%= camelName %>Collection.useOne(id);
	return raw ? resolveRelations(raw) : undefined;
}

// ============================================================================
// Mutations (Optimistic updates)
// ============================================================================

export function insert<%= className %>(data: Omit<<%= className %>, 'id'<% if (hasTimestamps) { %> | 'createdAt' | 'updatedAt'<% } %>>) {
	return <%= camelName %>Collection.insert({
		id: crypto.randomUUID(),
<% if (hasTimestamps) { -%>
		createdAt: new Date(),
		updatedAt: new Date(),
<% } -%>
		...data,
	} as <%= className %>);
}

export function update<%= className %>(id: string, fn: (draft: <%= className %>) => void) {
	return <%= camelName %>Collection.update(id, fn);
}

export function delete<%= className %>(id: string) {
	return <%= camelName %>Collection.delete(id);
}

// ============================================================================
// Field Metadata (for DataGrid, forms, admin)
// ============================================================================

export const <%= camelName %>Fields: Record<string, FieldMeta<<%= className %>Resolved>> = {
<% fields.forEach((field) => { -%>
<% // Skip entity ref internal fields from metadata display
if (field.isEntityRefType || field.isEntityRefId) return;
-%>
	<%= field.camelName %>: {
		field: '<%= field.camelName %>',
		label: '<%= field.ui_label %>',
		type: '<%= field.ui_type %>' as FieldType,
		importance: '<%= field.ui_importance %>' as FieldImportance,
<% if (field.ui_sortable) { -%>
		sortable: true,
<% } -%>
<% if (field.ui_filterable) { -%>
		filterable: true,
<% } -%>
<% if (field.ui_format) { -%>
		format: <%- JSON.stringify(field.ui_format) %>,
<% } -%>
<% if (field.hasChoices) { -%>
		choices: <%- JSON.stringify(field.choices) %>,
<% } -%>
<% if (field.foreignKey) { -%>
		reference: '<%= field.foreignKey.split('.')[0] %>',
<% } -%>
	},
<% }); -%>
<% // Add resolved relation fields to metadata
belongsToRelations.forEach((rel) => { -%>
	<%= rel.name %>: {
		field: '<%= rel.name %>',
		label: '<%= rel.targetClass.replace(/([A-Z])/g, ' $1').trim() %>',
		type: 'entity' as FieldType,
		importance: 'secondary' as FieldImportance,
		reference: '<%= rel.targetPlural %>',
	},
<% }); -%>
<% if (hasTimestamps) { -%>
	createdAt: {
		field: 'createdAt',
		label: 'Created',
		type: 'datetime' as FieldType,
		importance: 'tertiary' as FieldImportance,
		format: { dateFormat: 'relative' },
	},
	updatedAt: {
		field: 'updatedAt',
		label: 'Updated',
		type: 'datetime' as FieldType,
		importance: 'tertiary' as FieldImportance,
		format: { dateFormat: 'relative' },
	},
<% } -%>
};

export const <%= camelName %>Metadata = {
	name: '<%= name %>',
	plural: '<%= plural %>',
	displayName: '<%= className.replace(/([A-Z])/g, ' $1').trim() %>',
	displayNamePlural: '<%= classNamePlural.replace(/([A-Z])/g, ' $1').trim() %>',

	fields: <%= camelName %>Fields,

	// Display configuration
	primaryFields: [
<% fields.filter(f => f.ui_importance === 'primary').forEach(f => { -%>
		'<%= f.camelName %>',
<% }); -%>
	],
	searchFields: [
<% fields.filter(f => f.ui_filterable).forEach(f => { -%>
		'<%= f.camelName %>',
<% }); -%>
	],
	defaultSort: { field: '<% if (hasTimestamps) { %>createdAt<% } else { %>id<% } %>', direction: 'desc' as const },

	// Capabilities
	capabilities: {
		create: <%= exposeRepository || exposeTrpc %>,
		update: <%= exposeRepository || exposeTrpc %>,
		delete: <%= exposeRepository || exposeTrpc %>,
		list: true,
		get: true,
	},
} as const;

// ============================================================================
// Export bundle for registry
// ============================================================================

export const <%= camelName %> = {
	// Collection
	collection: <%= camelName %>Collection,

	// Hooks
	useMany: use<%= classNamePlural %>,
	useOne: use<%= className %>,

	// Mutations
	insert: insert<%= className %>,
	update: update<%= className %>,
	delete: delete<%= className %>,

	// Metadata
	fields: <%= camelName %>Fields,
	metadata: <%= camelName %>Metadata,
} as const;
