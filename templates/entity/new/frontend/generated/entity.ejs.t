---
to: <%= locations.frontendGenerated.path %>/<%= name %>.ts
force: true
---
/**
 * <%= className %> - Generated Entity Module
 *
 * AUTO-GENERATED by entity codegen - do not edit directly.
 * Source: entities/<%= name %>.yaml
 *
 * This file contains everything needed for the <%= className %> entity:
 * - Types (base + resolved with relations)
 * - Collection (Electric sync with optimistic mutations)
 * - Hooks (useMany, useOne with auto-resolved relations)
 * - Mutations (insert, update, delete)
 * - Field metadata (for DataGrid, forms, admin)
 */

<% if (frontend.sync.columnMapper) { -%>
import { <%= frontend.sync.columnMapper %> } from '@electric-sql/client';
<% } -%>
import { <%= camelName %>Schema, type <%= className %>Entity } from '<%= locations.dbEntities.import %><% if (locations.dbEntities.appendEntityName !== false) { %>/<%= name %><% } %>';
<% if (exposeTrpc) { -%>
import { trpc } from '<%= locations.trpcClient.import %>';
<% } -%>
import { electricCollectionOptions } from '@tanstack/electric-db-collection';
import { createCollection<% if (generate.hookStyle === 'useLiveQuery') { %>, useLiveQuery<% } %> } from '@tanstack/react-db';
<% if (generate.fieldMetadata) { -%>
import type { FieldMeta, FieldType, FieldImportance } from '<%= locations.frontendFieldMetaTypes.import %>/field-meta';
<% } -%>
<% if (frontend.auth.function) { -%>
import { <%= frontend.auth.function %> } from '<%= locations.frontendCollectionsAuth.import %>';
<% } -%>
<%
// Collect unique belongs_to targets for imports (FK resolution)
// Only import collections that actually exist (existingBelongsTo filters by targetExists)
const importedEntities = new Set();
existingBelongsTo.forEach((rel) => {
  if (rel.target !== name) {
    importedEntities.add(rel.target);
  }
});
-%>
<% if (importedEntities.size > 0) { -%>

// Import related collections for FK resolution
<% importedEntities.forEach((target) => {
  const targetCamel = target.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import { <%= targetCamel %>Collection } from './<%= target %>';
<% }); -%>
<% importedEntities.forEach((target) => {
  const targetClass = target.charAt(0).toUpperCase() + target.slice(1).replace(/_([a-z])/g, (_, c) => c.toUpperCase());
-%>
import type { <%= targetClass %>Entity } from '<%= locations.dbEntities.import %><% if (locations.dbEntities.appendEntityName !== false) { %>/<%= target %><% } %>';
<% }); -%>
<% } -%>

// ============================================================================
// Types
// ============================================================================

/** Base entity from database */
export type <%= className %> = <%= className %>Entity;
<% if (existingBelongsTo.length > 0) { -%>

/** Entity with resolved FK relations (only includes relations with existing targets) */
export interface <%= className %>Resolved extends <%= className %> {
<% existingBelongsTo.forEach((rel) => { -%>
<% // Use local type for self-referential, imported type for others -%>
	<%= rel.name %>?: <%= rel.target === name ? className : rel.targetClass + 'Entity' %>;
<% }); -%>
}
<% } else { -%>

/** Entity type (no FK relations to resolve) */
export type <%= className %>Resolved = <%= className %>;
<% } -%>

// ============================================================================
// Collection (Electric sync with optimistic mutations)
// ============================================================================
<% if (hasSoftDelete) { -%>

// TODO: Backend Electric shape endpoint should filter soft-deleted records
// by including WHERE deleted_at IS NULL in the shape configuration.
// Without this filter, soft-deleted records will reappear after Electric sync.
<% } -%>

export const <%= camelName %>Collection = createCollection(
	electricCollectionOptions({
		id: '<%= plural %>',
		shapeOptions: {
<% if (frontend.sync.useTableParam) { -%>
			url: new URL(
				'<%= frontend.sync.shapeUrl %>',
				typeof window !== 'undefined'
					? window.location.origin
					: 'http://localhost:5173',
			).toString(),
			params: {
				table: '<%= plural %>',
			},
<% } else { -%>
			url: `<%= frontend.sync.shapeUrl %>/<%= plural %>`,
<% } -%>
<% if (frontend.auth.function) { -%>
			headers: {
				Authorization: <%= frontend.auth.function %>,
			},
<% } -%>
			parser: {
<% Object.entries(frontend.parsers).forEach(([type, fn]) => { -%>
				<%- type %>: <%- fn %>,
<% }); -%>
			},
<% if (frontend.sync.columnMapper) { -%>
			columnMapper: <%= frontend.sync.columnMapper %>(),
<% } -%>
		},
		schema: <%= camelName %>Schema,
		getKey: (item) => item.id,
<% if (exposeTrpc) { -%>
		onInsert: async ({ transaction }) => {
			const { modified } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.create.mutate(modified);
			return { txid: result.txid };
		},
		onUpdate: async ({ transaction }) => {
			const { modified } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.update.mutate({ id: modified.id, data: modified });
			return { txid: result.txid };
		},
		onDelete: async ({ transaction }) => {
			const { original } = transaction.mutations[0];
			const result = await trpc.<%= plural %>.delete.mutate({ id: original.id });
			return { txid: result.txid };
		},
<% } -%>
	}),
);

// ============================================================================
// Resolution (FK lookup - internal use)
// ============================================================================
<% if (existingBelongsTo.length > 0) { -%>

function resolveRelations(entity: <%= className %>): <%= className %>Resolved {
	return {
		...entity,
<% existingBelongsTo.forEach((rel) => { -%>
		<%= rel.name %>: entity.<%= rel.foreignKeyCamel %>
			? <%= rel.target.replace(/_([a-z])/g, (_, c) => c.toUpperCase()) %>Collection.state.get(entity.<%= rel.foreignKeyCamel %>)
			: undefined,
<% }); -%>
	};
}
<% } else { -%>

function resolveRelations(entity: <%= className %>): <%= className %>Resolved {
	return entity;
}
<% } -%>

// ============================================================================
// Hooks (React hooks returning resolved entities)
// ============================================================================
<% if (generate.hookStyle === 'useLiveQuery') { -%>

/** Get all <%= plural %> with relations resolved */
export function use<%= classNamePlural %>() {
	const { data, isLoading } = useLiveQuery((q) =>
		q.from({ <%= camelName %>Collection }),
	);
	return {
		data: data?.map(resolveRelations) ?? [],
		isLoading,
	};
}

/** Get single <%= camelName %> by ID with relations resolved */
export function use<%= className %>(id: string | undefined) {
	const { data, isLoading } = useLiveQuery((q) =>
		q.from({ <%= camelName %>Collection }),
	);
	const entity = data?.find((item) => item.id === id);
	return {
		data: entity ? resolveRelations(entity) : undefined,
		isLoading,
	};
}
<% } else { -%>

/** Get all <%= plural %> with relations resolved */
export function use<%= classNamePlural %>(): <%= className %>Resolved[] {
	const raw = <%= camelName %>Collection.useMany();
	return raw.map(resolveRelations);
}

/** Get single <%= camelName %> by ID with relations resolved */
export function use<%= className %>(id: string | undefined): <%= className %>Resolved | undefined {
	const raw = <%= camelName %>Collection.useOne(id);
	return raw ? resolveRelations(raw) : undefined;
}
<% } -%>

<% if (generate.mutations) { -%>
// ============================================================================
// Mutations (Optimistic updates)
// ============================================================================

export function insert<%= className %>(data: Omit<<%= className %>, 'id'<% if (hasTimestamps) { %> | 'createdAt' | 'updatedAt'<% } %>>) {
	return <%= camelName %>Collection.insert({
		id: crypto.randomUUID(),
<% if (hasTimestamps) { -%>
		createdAt: new Date(),
		updatedAt: new Date(),
<% } -%>
		...data,
	} as <%= className %>);
}

export function update<%= className %>(id: string, fn: (draft: <%= className %>) => void) {
	return <%= camelName %>Collection.update(id, fn);
}

export function delete<%= className %>(id: string) {
	return <%= camelName %>Collection.delete(id);
}
<% } -%>
<% if (generate.fieldMetadata) { -%>

// ============================================================================
// Field Metadata (for DataGrid, forms, admin)
// ============================================================================

export const <%= camelName %>Fields: Record<string, FieldMeta<<%= className %>Resolved>> = {
<% fields.forEach((field) => { -%>
<% // Skip entity ref internal fields from metadata display
if (field.isEntityRefType || field.isEntityRefId) return;
-%>
	<%= field.camelName %>: {
		field: '<%= field.camelName %>',
		label: '<%= field.ui_label %>',
		type: '<%= field.ui_type %>' as FieldType,
		importance: '<%= field.ui_importance %>' as FieldImportance,
<% if (field.ui_sortable) { -%>
		sortable: true,
<% } -%>
<% if (field.ui_filterable) { -%>
		filterable: true,
<% } -%>
<% if (field.ui_format) { -%>
		format: <%- JSON.stringify(field.ui_format) %>,
<% } -%>
<% if (field.hasChoices) { -%>
		choices: <%- JSON.stringify(field.choices) %>,
<% } -%>
<% if (field.foreignKey) { -%>
		reference: '<%= field.foreignKey.split('.')[0] %>',
<% } -%>
	},
<% }); -%>
<% // Add resolved relation fields to metadata
belongsToRelations.forEach((rel) => { -%>
	<%= rel.name %>: {
		field: '<%= rel.name %>',
		label: '<%= rel.targetClass.replace(/([A-Z])/g, ' $1').trim() %>',
		type: 'entity' as FieldType,
		importance: 'secondary' as FieldImportance,
		reference: '<%= rel.targetPlural %>',
	},
<% }); -%>
<% if (hasTimestamps) { -%>
	createdAt: {
		field: 'createdAt',
		label: 'Created',
		type: 'datetime' as FieldType,
		importance: 'tertiary' as FieldImportance,
		format: { dateFormat: 'relative' },
	},
	updatedAt: {
		field: 'updatedAt',
		label: 'Updated',
		type: 'datetime' as FieldType,
		importance: 'tertiary' as FieldImportance,
		format: { dateFormat: 'relative' },
	},
<% } -%>
};

export const <%= camelName %>Metadata = {
	name: '<%= name %>',
	plural: '<%= plural %>',
	displayName: '<%= className.replace(/([A-Z])/g, ' $1').trim() %>',
	displayNamePlural: '<%= classNamePlural.replace(/([A-Z])/g, ' $1').trim() %>',

	fields: <%= camelName %>Fields,

	// Display configuration
	primaryFields: [
<% fields.filter(f => f.ui_importance === 'primary').forEach(f => { -%>
		'<%= f.camelName %>',
<% }); -%>
	],
	searchFields: [
<% fields.filter(f => f.ui_filterable).forEach(f => { -%>
		'<%= f.camelName %>',
<% }); -%>
	],
	defaultSort: { field: '<% if (hasTimestamps) { %>createdAt<% } else { %>id<% } %>', direction: 'desc' as const },

	// Capabilities
	capabilities: {
		create: <%= exposeRepository || exposeTrpc %>,
		update: <%= exposeRepository || exposeTrpc %>,
		delete: <%= exposeRepository || exposeTrpc %>,
		list: true,
		get: true,
	},
} as const;
<% } -%>

// ============================================================================
// Export bundle for registry
// ============================================================================

export const <%= camelName %> = {
	// Collection
	collection: <%= camelName %>Collection,

	// Hooks
	useMany: use<%= classNamePlural %>,
	useOne: use<%= className %>,
<% if (generate.mutations) { -%>

	// Mutations
	insert: insert<%= className %>,
	update: update<%= className %>,
	delete: delete<%= className %>,
<% } -%>
<% if (generate.fieldMetadata) { -%>

	// Metadata
	fields: <%= camelName %>Fields,
	metadata: <%= camelName %>Metadata,
<% } -%>
} as const;
