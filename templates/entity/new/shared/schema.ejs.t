---
to: <%= locations.dbEntities.path %>/<%= name %>.ts
force: true
---
/**
 * <%= className %> Shared Schema
 * Generated by entity codegen - do not edit directly
 */

import { z } from 'zod';
<% if (hasEntityRefFields) { -%>
import { entityTypeSchema } from '../context-engine';
<% } -%>

// Base schema
export const <%= camelName %>Schema = z.object({
	id: z.string().uuid(),
<% fields.forEach((field) => { -%>
<% let zodChain = field.zodType; -%>
<% if (field.type === 'string' && field.maxLength) { zodChain += `.max(${field.maxLength})`; } -%>
<% if (field.type === 'string' && field.minLength) { zodChain += `.min(${field.minLength})`; } -%>
<% if (['integer', 'decimal'].includes(field.type) && field.min !== undefined) { zodChain += `.min(${field.min})`; } -%>
<% if (['integer', 'decimal'].includes(field.type) && field.max !== undefined) { zodChain += `.max(${field.max})`; } -%>
<% if (field.choices) { zodChain = `z.enum([${field.choices.map(c => `'${c}'`).join(', ')}])`; } -%>
<% if (field.nullable) { zodChain += '.nullable()'; } -%>
	<%- field.camelName %>: <%- zodChain %>,
<% }) -%>
<% /* ================================================================== */ -%>
<% /* Behavior fields                                                    */ -%>
<% /* ================================================================== */ -%>
<% if (hasTimestamps) { -%>
	// timestamps behavior
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
<% } -%>
<% if (hasSoftDelete) { -%>
	// soft_delete behavior
	deletedAt: z.coerce.date().nullable(),
<% } -%>
<% if (hasUserTracking) { -%>
	// user_tracking behavior
	createdBy: z.string().uuid().nullable(),
	updatedBy: z.string().uuid().nullable(),
<% } -%>
<% if (hasTemporalValidity) { -%>
	// temporal_validity behavior
	validFrom: z.coerce.date().nullable(),
	validTo: z.coerce.date().nullable(),
	isActive: z.boolean(),
<% } -%>
});

export type <%= className %>Entity = z.infer<typeof <%= camelName %>Schema>;

// Create schema (for mutations)
export const create<%= className %>Schema = z.object({
<% fields.forEach((field) => { -%>
<% let zodChain = field.zodType; -%>
<% if (field.type === 'string' && field.maxLength) { zodChain += `.max(${field.maxLength})`; } -%>
<% if (field.type === 'string' && field.minLength) { zodChain += `.min(${field.minLength})`; } -%>
<% if (['integer', 'decimal'].includes(field.type) && field.min !== undefined) { zodChain += `.min(${field.min})`; } -%>
<% if (['integer', 'decimal'].includes(field.type) && field.max !== undefined) { zodChain += `.max(${field.max})`; } -%>
<% if (field.choices) { zodChain = `z.enum([${field.choices.map(c => `'${c}'`).join(', ')}])`; } -%>
<% if (field.nullable) { zodChain += '.nullable()'; } -%>
<% if (!field.required) { zodChain += '.optional()'; } -%>
	<%- field.camelName %>: <%- zodChain %>,
<% }) -%>
});

export type Create<%= className %>Input = z.infer<typeof create<%= className %>Schema>;

// Update schema (for mutations)
export const update<%= className %>Schema = z.object({
<% fields.forEach((field) => { -%>
<% let zodChain = field.zodType; -%>
<% if (field.type === 'string' && field.maxLength) { zodChain += `.max(${field.maxLength})`; } -%>
<% if (field.type === 'string' && field.minLength) { zodChain += `.min(${field.minLength})`; } -%>
<% if (['integer', 'decimal'].includes(field.type) && field.min !== undefined) { zodChain += `.min(${field.min})`; } -%>
<% if (['integer', 'decimal'].includes(field.type) && field.max !== undefined) { zodChain += `.max(${field.max})`; } -%>
<% if (field.choices) { zodChain = `z.enum([${field.choices.map(c => `'${c}'`).join(', ')}])`; } -%>
<% if (field.nullable) { zodChain += '.nullable()'; } -%>
	<%- field.camelName %>: <%- zodChain %>.optional(),
<% }) -%>
});

export type Update<%= className %>Input = z.infer<typeof update<%= className %>Schema>;

// Mutation schemas (for tRPC)
export const <%= camelName %>MutationSchemas = {
	create: create<%= className %>Schema,
	update: z.object({
		id: z.string().uuid(),
		data: update<%= className %>Schema,
	}),
	delete: z.object({
		id: z.string().uuid(),
	}),
<% if (hasSoftDelete) { -%>
	restore: z.object({
		id: z.string().uuid(),
	}),
<% } -%>
};
