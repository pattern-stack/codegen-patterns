/**
 * Opportunity Domain Entity
 * Generated by entity codegen - do not edit directly
 *
 * NOTE: Related entity imports assume a nested folder structure where each entity
 * lives in its own folder (e.g., domain/{entity}/{entity}.entity.ts). This follows
 * CLEAN architecture conventions where each aggregate root has its own bounded context.
 * All entities should follow this structure for consistent imports.
 */

import type { Organization } from '../organization/organization.entity';
import type { User } from '../user/user.entity';
import type { DealState } from '../deal_state/deal_state.entity';

export class Opportunity {
	constructor(
		public readonly id: string,
		public readonly tenantId: string,
		public readonly name: string,
		public readonly organizationId: string,
		public readonly ownerId: string,
		public readonly stateId: string,
		public readonly amount: number | null,
		public readonly currency: string | null,
		public readonly expectedCloseDate: Date | null,
		public readonly closedAt: Date | null,
		// Loaded relations (optional, populated when eager-loaded)
		public readonly organization?: Organization,
		public readonly owner?: User,
		public readonly state?: DealState,
	) {}

	static fromRecord(
		// biome-ignore lint/suspicious/noExplicitAny: Drizzle records have dynamic shape
		record: Record<string, any>,
		// biome-ignore lint/suspicious/noExplicitAny: Returns different entity types
		mapRelation?: (name: string, data: unknown) => any,
	): Opportunity {
		return new Opportunity(
			record.id,
			record.tenantId,
			record.name,
			record.organizationId,
			record.ownerId,
			record.stateId,
			record.amount,
			record.currency,
			record.expectedCloseDate,
			record.closedAt,
			record.organization ? mapRelation?.('organization', record.organization) : undefined,
			record.owner ? mapRelation?.('owner', record.owner) : undefined,
			record.state ? mapRelation?.('state', record.state) : undefined,
		);
	}
}
